\input texinfo.tex
@c %**start of header
@setfilename mp-odrf.info
@settitle Multiple Precision One--Dimensional Root--Finding
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Multiple Precision One--Dimensional Root--Finding

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MP-ODRF

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mp-odrf

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2014

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C
language library reimplementing the one--dimensional root--finding
algorithms from the @gnu{} Scientific Library using the multiple
precision numbers defined by @mpfr{}.  The package is distributed under
the terms of the @gnu{} General Public License (@gpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*
Copyright @copyright{} 1996, 1997, 1998, 1999, 2000, 2001, 2002,
2003, 2004, 2005, 2006, 2007, 2008 The GSL Team.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mp-odrf: (mp-odrf).           @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* one root::                    One--dimensional root--finding.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* resources::                   On--line resources.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C
language library reimplementing the one--dimensional root--finding
algorithms from the @gnu{} Scientific Library (@gsl{}) using the
multiple precision numbers defined by @mpfr{}.

This package depends upon the following packages: @gmp{}, the @gnu{}
Multiple Precision arithmetic library; @mpfr{}, the Multiple Precision
Floating--Point Reliable library.

Both the code and the documentation are reworked from the original
@gsl{} distribution; however this package does not depend on the @gsl{}
being installed.

@value{PACKAGE} installs the single header file @file{mp-odrf.h}.  All
the function names in the @api{} are prefixed with @code{mp_odrf_}; all
the constant names are prefixed with @code{MP_ODRF_}; all the type names
are prefixed with @code{mp_odrf_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}; we can
inspect it with:

@example
$ pkg-config libmpodrf --cflags
-I/usr/local/include

$ pkg-config libmpodrf --libs
-L/usr/local/lib64 -lmpodrf
@end example

When preparing a package that must link with the library distributed by
@value{PACKAGE}, we can use the @gnu{} Autotools as follows:

@itemize
@item
Install the file @file{pkg.m4} from @file{/usr/share/aclocal} into the
source tree of the package, for example under @file{meta/autoconf/}.

@item
Include @file{pkg.m4} in the template @file{configure.ac} by adding the
following line to @file{acinclude.m4}:

@example
m4_include(meta/autoconf/pkg.m4)
@end example

@item
Search for the @gmp{} and @mpfr{} libraries:

@example
AC_CHECK_HEADERS([gmp.h],,
  [AC_MSG_ERROR([Cannot find libgmp.])])
AC_CHECK_LIB([gmp],[__gmpn_add],,
  [AC_MSG_ERROR([Cannot find libgmp.])])

AC_CHECK_HEADERS([mpfr.h],,
  [AC_MSG_FAILURE([missing mpfr.h header],[2])])
AC_CHECK_LIB([mpfr],[mpfr_init],,
  [AC_MSG_FAILURE([missing or unusable MPFR library],[2])])
@end example

@item
Add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([MP_ODRF],[mp-odrf >= 0.1])
@end example

@noindent
which will set the variables @code{MP_ODRF_LIBS} and
@code{MP_ODRF_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([mpodrf],[mp_odrf_version_string],,
  [AC_MSG_FAILURE([test for MP ODRF library failed])])
AC_CHECK_HEADERS([mp-odrf.h],,
  [AC_MSG_FAILURE([test for MP ODRF header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} mp_odrf_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int mp_odrf_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mp_odrf_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int mp_odrf_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node one root
@chapter One--dimensional root--finding


@cindex root finding
@cindex zero finding
@cindex finding roots
@cindex finding zeros
@cindex roots
@cindex solving a nonlinear equation
@cindex nonlinear equation, solutions of

This chapter describes routines for finding roots of arbitrary
one-dimensional functions.  The library provides low level components
for a variety of iterative solvers and convergence tests.  These can be
combined by the user to achieve the desired solution, with full access
to the intermediate steps of the iteration.  Each class of methods uses
the same framework, so that we can switch between solvers at runtime
without needing to recompile our program.  Each instance of a solver
keeps track of its own state, allowing the solvers to be used in
multi--threaded programs.

@menu
* one root overview::           Root Finding Overview.
* one root caveats::            Root Finding Caveats.
* one root errors::             Describing errors.
* one root init::               Initializing the Solver.
* one root func::               Providing the function to solve.
* one root bounds::             Search Bounds and Guesses.
* one root iteration::          Root Finding Iteration.
* one root stop::               Search Stopping Parameters.
* one root bracketing::         Root Bracketing Algorithms.
* one root polishing::          Root Finding Algorithms using Derivatives.
* one root examples::           Root Finding Examples.
* one root references::         Root Finding References and Further
                                Reading.
@end menu

@c page
@node one root overview
@section Overview
@cindex root finding, overview


One--dimensional root finding algorithms can be divided into two
classes: @dfn{root bracketing} and @dfn{root polishing}.

Algorithms which proceed by bracketing a root are guaranteed to
converge.  Bracketing algorithms begin with a bounded region known to
contain a root.  The size of this bounded region is reduced,
iteratively, until it encloses the root to a desired tolerance.  This
provides a rigorous error estimate for the location of the root.

The technique of root polishing attempts to improve an initial guess to
the root.  These algorithms converge only if started ``close enough'' to
a root, and sacrifice a rigorous error bound for speed.  By
approximating the behavior of a function in the vicinity of a root they
attempt to find a higher order improvement of an initial guess.  When
the behavior of the function is compatible with the algorithm and a good
initial guess is available a polishing algorithm can provide rapid
convergence.

In @value{PACKAGE} both types of algorithm are available in similar
frameworks.  The user provides a high--level driver for the algorithms,
and the library provides the individual functions necessary for each of
the steps.  There are three main phases of the iteration.  The steps
are:

@enumerate
@item
Initialize solver state @var{S} for algorithm @var{T}.

@item
Update @var{S} using the iteration @var{T}.

@item
Test @var{S} for convergence, and repeat iteration if necessary.
@end enumerate

@noindent
The state for bracketing solvers is held in a
@code{mp_odrf_mpfr_root_fsolver_t} struct; the updating procedure uses
only function evaluations (not derivatives).  The state for root
polishing solvers is held in a @code{mp_odrf_mpfr_root_fdfsolver_t}
struct; the updates require both the function and its derivative (hence
the name @code{fdf}) to be supplied by the user.

@c page
@node one root caveats
@section Caveats
@cindex root finding, caveats


Note that root finding functions can only search for one root at a time.
When there are several roots in the search area, the first root to be
found will be returned; however it is difficult to predict which of the
roots this will be.  @emph{In most cases, no error will be reported if
you try to find a root in an area where there is more than one.}

Care must be taken when a function may have a multiple root (such as
@c{$f(x) = (x-x_0)^2$}
@math{f(x) = (x-x_0)^2} or
@c{$f(x) = (x-x_0)^3$}
@math{f(x) = (x-x_0)^3}).
It is not possible to use root--bracketing algorithms on
even--multiplicity roots.  For these algorithms the initial interval must
contain a zero-crossing, where the function is negative at one end of
the interval and positive at the other end.  Roots with even--multiplicity
do not cross zero, but only touch it instantaneously.  Algorithms based
on root bracketing will still work for odd--multiplicity roots
(e.g. cubic, quintic, @dots{}).
Root polishing algorithms generally work with higher multiplicity roots,
but at a reduced rate of convergence.  In these cases the @dfn{Steffenson
algorithm} can be used to accelerate the convergence of multiple roots.

While it is not absolutely required that @math{f} have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the @emph{existence} of roots.  There are better
ways to do this.  Because it is easy to create situations where numerical
root finders can fail, it is a bad idea to throw a root finder at a
function you do not know much about.  In general it is best to examine
the function visually by plotting before searching for a root.

@c page
@node one root errors
@section Describing errors


@deftp {Enum Typedef} mp_odrf_code_t
Type of integers used to represent result conditions and error codes.
The following symbols are defined:

@table @code
@item MP_ODRF_POSITIVE_ERROR_CODE_LIMIT
Positive integer being one more of the maximum defined code.

@item MP_ODRF_CONTINUE
Positive integer.  Used to signal that an iteration is allowed to go on
with the next step.

@item MP_ODRF_OK
No error, successful operation.  It is defined to be @code{0}.

@item MP_ODRF_ERROR
Negative integer representing an error not signaled by @value{PACKAGE}.

@item MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT
@itemx MP_ODRF_ERROR_INVALID_BRACKET_INTERVAL
@itemx MP_ODRF_ERROR_RELATIVE_TOLERANCE_IS_NEGATIVE
@itemx MP_ODRF_ERROR_ABSOLUTE_TOLERANCE_IS_NEGATIVE
@itemx MP_ODRF_ERROR_LOWER_BOUND_LARGER_THAN_UPPER_BOUND
@itemx MP_ODRF_ERROR_ENDPOINTS_DO_NOT_STRADDLE
@itemx MP_ODRF_ERROR_FUNCTION_VALUE_IS_NOT_FINITE
@itemx MP_ODRF_ERROR_DERIVATIVE_IS_ZERO
@itemx MP_ODRF_ERROR_FUNCTION_OR_DERIVATIVE_VALUE_INVALID
Negative integers representing error causes.

@item MP_ODRF_NEGATIVE_ERROR_CODE_LIMIT
Negative integer being one less of the minimum defined error code.
@end table
@end deftp


@deftypefun {const char *} mp_odrf_strerror (mp_odrf_code_t @var{code})
Return a pointer to a statically allocated @asciiz{} string describing
the error represented by @var{code}.
@end deftypefun

@c page
@node one root init
@section Initializing the Solver


@menu
* one root init fsolver::       Initializing function only solvers.
* one root init fdfsolver::     Initializing function and derivative
                                solvers.
@end menu

@c page
@node one root init fsolver
@subsection Initializing function only solvers


Here is an example of initializing and finalizing a solver for root
bracketing problems using the bisection algorithm:

@example
#include <mp-odrf.h>

const mp_odrf_mpfr_root_fsolver_driver_t *  T;
mp_odrf_mpfr_root_fsolver_t *   S;

T = mp_odrf_mpfr_root_fsolver_bisection;
S = mp_odrf_mpfr_root_fsolver_alloc (T);
if (NULL != S) @{
  /* do something here */
  mp_odrf_mpfr_root_fsolver_free(S);
@} else @{
  fprintf(stderr, "error: %s\n",
    mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
@}
@end example


@deftp {Struct Typedef} mp_odrf_mpfr_root_fsolver_t
Type of solver for root bracketing solvers.
@end deftp


@deftypefun {mp_odrf_mpfr_root_fsolver_t *} mp_odrf_mpfr_root_fsolver_alloc (const mp_odrf_mpfr_root_fsolver_driver_t * @var{T})
Allocate a new instance of a solver of type @var{T}; if successful
return a pointer to the solver structure, otherwise return @cnull{}.
This function returns @cnull{} only when memory allocation through
@cfunc{malloc} fails.
@end deftypefun


@deftypefun void mp_odrf_mpfr_root_fsolver_free (mp_odrf_mpfr_root_fsolver_t * @var{s})
Free all the memory associated with the solver @var{s}.
@end deftypefun


@deftypefun mp_odrf_code_t mp_odrf_mpfr_root_fsolver_set (mp_odrf_mpfr_root_fsolver_t * @var{S}, mp_odrf_mpfr_function_t * @var{F}, mpfr_ptr @var{x_lower}, mpfr_ptr @var{x_upper})
Initialize, or reinitialize, an existing solver @var{S} to use the
function @var{F} and the initial search interval @code{[@var{x_lower},
@var{x_upper}]}.  When successful return @code{MP_ODRF_OK}, otherwise
return an error code.
@end deftypefun


@deftypefun {const char *} mp_odrf_mpfr_root_fsolver_name (const mp_odrf_mpfr_root_fsolver_t * @var{S})
Return a pointer to a statically allocated @asciiz{} string representing
the name of the algorithm used by @var{S}.
@end deftypefun

@c page
@node one root init fdfsolver
@subsection Initializing function and derivative solvers


Here is an example of initializing and finalizing a solver for root
polishing problems using the Newton--Raphson algorithm:

@example
#include <mp-odrf.h>

const mp_odrf_mpfr_root_fdfsolver_driver_t *  T;
mp_odrf_mpfr_root_fdfsolver_t *  S;

T = mp_odrf_mpfr_root_fdfsolver_newton;
S = mp_odrf_mpfr_root_fdfsolver_alloc (T);
if (NULL != S) @{
  /* do something here */
  mp_odrf_mpfr_root_fdfsolver_free(S);
@} else @{
  fprintf(stderr, "error: %s\n",
    mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
@}
@end example


@deftp {Struct Typedef} mp_odrf_mpfr_root_fdfsolver_t
Type of solver for root polishing solvers.
@end deftp


@deftypefun {mp_odrf_mpfr_root_fdfsolver_t *} mp_odrf_mpfr_root_fdfsolver_alloc (const mp_odrf_mpfr_root_fdfsolver_driver_t * @var{T})
Allocate a new instance of a derivative--based solver of type @var{T};
if successful return a pointer to the solver structure, otherwise
return @cnull{}.  This function returns @cnull{} only when memory
allocation through @cfunc{malloc} fails.
@end deftypefun


@deftypefun void mp_odrf_mpfr_root_fdfsolver_free (mp_odrf_mpfr_root_fdfsolver_t * @var{S})
Free all the memory associated with the solver @var{S}.
@end deftypefun


@deftypefun mp_odrf_code_t mp_odrf_mpfr_root_fdfsolver_set (mp_odrf_mpfr_root_fdfsolver_t * @var{S}, mp_odrf_mpfr_function_fdf_t * @var{fdf}, mpfr_ptr @var{root})
Initialize, or reinitialize, an existing solver @var{S} to use the
function and derivative @var{FDF} and the initial guess @var{root}.
When successful return @code{MP_ODRF_OK}, otherwise return an error
code.
@end deftypefun


@deftypefun {const char *} mp_odrf_mpfr_root_fdfsolver_name (const mp_odrf_mpfr_root_fdfsolver_t * @var{S})
Return a pointer to a statically allocated @asciiz{} string representing
the name of the algorithm used by @var{S}.
@end deftypefun

@c page
@node one root func
@section Providing the function to solve


@cindex root finding, providing a function to solve


We must provide a continuous function of one variable for the root
finders to operate on, and, sometimes, its first derivative.  In order
to allow for general parameters the functions are defined by the data
types described in this section.


@menu
* one root func proto::         Mathematical function prototypes.
* one root func only::          Providing only the function.
* one root func deriv::         Providing the function and its
                                derivative.
@end menu

@c page
@node one root func proto
@subsection Mathematical function prototypes


@deftypefn {Prototype Typedef} int mp_odrf_mpfr_wrapped_f_t (mpfr_ptr @var{Y}, mpfr_ptr @var{X}, void * @var{params})
Function prototype used to describe the signature of the C function that
computes the mathematical function subject of the problem.

The actual implementation function must compute the mathematical
function at abscissa @var{X} and store the result in @var{Y} which must
be already initialised.  @var{params} can be used to hand custom data to
the function implementation.

When successful the function must return @code{MP_ODRF_OK}.  If an error
occurs: it must return an appropriate error code, which can be a value
of type @code{mp_odrf_code_t} or a user--defined code.

@quotation
@strong{HINT} If a function implementation must signal an error with
associated data: such data can be stored in an appropriate data
structure referenced by @var{params}.
@end quotation
@end deftypefn


@deftypefn {Prototype Typedef} int mp_odrf_mpfr_wrapped_fdf_t (mpfr_ptr @var{DY}, mpfr_ptr @var{Y}, mpfr_ptr @var{X}, void * @var{PARAMS})
Function prototype used to describe the signature of the C function that
computes the mathematical function subject of the problem and its
derivative.

The actual implementation function must compute the mathematical
function and its derivative at abscissa @var{X} and store the results in
@var{Y} and @var{DY} which must be already initialised.  @var{params}
can be used to hand custom data to the function implementation.

When successful the function must return @code{MP_ODRF_OK}.  If an error
occurs: it must return an appropriate error code, which can be a value
of type @code{mp_odrf_code_t} or a user--defined code.

@quotation
@strong{HINT} If a function implementation must signal an error with
associated data: such data can be stored in an appropriate data
structure referenced by @var{params}.
@end quotation
@end deftypefn

@c page
@node one root func only
@subsection Providing only the function


@deftp {Struct Typedef} mp_odrf_mpfr_function_t
This data type defines a general math function with parameters.  Public
fields description follows.

@table @code
@item mp_odrf_mpfr_wrapped_f_t * function
Pointer to a C function that computes the mathematical function at a
given abscissa.

@item void * params
A pointer to the parameters of the function.  When unused it can be set
to @cnull{}.
@end table
@end deftp


@deftypefn {Preprocessor Macro} int MP_ODRF_MPFR_FN_EVAL (mp_odrf_mpfr_function_t * @var{F}, mpfr_ptr @var{Y}, mpfr_ptr @var{X})
Apply the math function described by @var{F} to the value @var{X} and
store the result in @var{Y}.  When successful return @code{MP_ODRF_OK};
if an error occurs return a suitable error code.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Example

Here is an example for the general quadratic function:
@tex
$$
f(x) = a x^2 + b x + c
$$
@end tex
@ifinfo

@example
f(x) = a x^2 + b x + c
@end example

@end ifinfo
@noindent
with @math{a = 3}, @math{b = 2}, @math{c = 1}.  The following code
defines an @code{mp_odrf_mpfr_function_t} @var{F} which we could pass to
a root finder, then invokes it and prints the result.

@smallexample
#include <mp-odrf.h>

typedef struct @{
  mpfr_t        a;
  mpfr_t        b;
  mpfr_t        c;
@} parameters_t;

static void
parameters_init (parameters_t * params)
@{
  mpfr_init(params->a);
  mpfr_init(params->b);
  mpfr_init(params->c);

  mpfr_set_d(params->a, 3.0, GMP_RNDN);
  mpfr_set_d(params->b, 2.0, GMP_RNDN);
  mpfr_set_d(params->c, 1.0, GMP_RNDN);
@}
static void
parameters_final (parameters_t * params)
@{
  mpfr_clear(params->a);
  mpfr_clear(params->b);
  mpfr_clear(params->c);
@}

int
function (mpfr_ptr Y, mpfr_ptr X, void * params_)
@{
  mpfr_t        tmp1;
  mpfr_t        tmp2;
  parameters_t *params = params_;

  mpfr_init(tmp1);
  mpfr_init(tmp2);
  @{
    /* (a * x + b) * x + c */
    mpfr_mul(tmp1, params->a, X, GMP_RNDN);
    mpfr_add(tmp2, tmp1, params->b, GMP_RNDN);
    mpfr_mul(tmp1, tmp2, X, GMP_RNDN);
    mpfr_add(Y, tmp1, params->c, GMP_RNDN);
  @}
  mpfr_clear(tmp1);
  mpfr_clear(tmp2);
  return MP_ODRF_OK;
@}

int
main (int argc MP_ODRF_MPFR_UNUSED, char * argv [])
@{
  parameters_t             params;
  mpfr_t                   Y;
  mpfr_t                   X;
  mp_odrf_mpfr_function_t  F = @{
    .function = function,
    .params   = &params
  @};
  int                      rv;
  double                   x = 2.4;

  parameters_init(&params);
  mpfr_init(Y);
  mpfr_init(X);
  @{
    mpfr_set_d(X, 2.4, GMP_RNDN);
    rv = MP_ODRF_MPFR_FN_EVAL(&F, Y, X);
    mpfr_fprintf(stderr,
      "%s: the function value is: %20RNf, should be close to: %f\n",
      argv[0], Y, (3.0 * x * x + 2.0 * x + 1.0));
  @}
  mpfr_clear(X);
  mpfr_clear(Y);
  parameters_final(&params);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root func deriv
@subsection Providing the function and its derivative


@deftp {Data Type} mp_odrf_mpfr_function_fdf_t
This data type defines a general math function with parameters and its
first derivative.  Public fields description follows.

@table @code
@item mp_odrf_mpfr_wrapped_f_t * f
Pointer to a C function that computes the mathematical function at a
given abscissa.

@item mp_odrf_mpfr_wrapped_f_t * df
Pointer to a C function that computes the derivative of the mathematical
function at a given abscissa.

@item mp_odrf_mpfr_wrapped_fdf_t * fdf
Pointer to a C function that computes both the mathematical function and
its derivative at a given abscissa.

@item void * params
A pointer to the parameters of the function.  When unused it can be set
to @cnull{}.
@end table
@end deftp


@deftypefn {Preprocessor Macro} int MP_ODRF_MPFR_FN_FDF_EVAL_F (mp_odrf_mpfr_function_fdf_t * @var{FDF}, mpfr_ptr @var{Y}, mpfr_ptr @var{X})
Apply the math function described by @var{FDF} to the value @var{X} and
store the result in @var{Y}.  When successful return @code{MP_ODRF_OK};
if an error occurs return a suitable error code.
@end deftypefn


@deftypefn {Preprocessor Macro} int MP_ODRF_MPFR_FN_FDF_EVAL_DF (mp_odrf_mpfr_function_fdf_t * @var{FDF}, mpfr_ptr @var{Y}, mpfr_ptr @var{X})
Apply the derivative of the math function described by @var{FDF} to the
value @var{X} and store the result in @var{Y}.  When successful return
@code{MP_ODRF_OK}; if an error occurs return a suitable error code.
@end deftypefn


@deftypefn {Preprocessor Macro} int MP_ODRF_MPFR_FN_FDF_EVAL_F_DF (mp_odrf_mpfr_function_fdf_t * @var{FDF}, mpfr_ptr @var{DY}, mpfr_ptr @var{Y}, mpfr_ptr @var{X})
Apply both the math function described by @var{FDF} and its derivative
to the value @var{X} and store the results in @var{Y} and @var{DY}.
When successful return @code{MP_ODRF_OK}; if an error occurs return a
suitable error code.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Example

Here is an example for the general quadratic function,
@tex
$$
f(x) = a x^2 + b x + c
$$
@end tex
@ifinfo

@example
f(x) = a x^2 + b x + c
@end example

@end ifinfo
@noindent
with @math{a = 3}, @math{b = 2}, @math{c = 1}, and its derivative:
@tex
$$
f'(x) = 2 a x + b
$$
@end tex
@ifinfo

@example
f'(x) = 2 a x + b
@end example

@end ifinfo
The following code defines an @code{mp_odrf_mpfr_function_fdf_t}
@var{FDF} which we could pass to a root finder, then invokes it and
prints the result.

@smallexample
#include <mp-odrf.h>

typedef struct @{
  mpfr_t        a;
  mpfr_t        b;
  mpfr_t        c;
@} parameters_t;

static void
parameters_init (parameters_t * params)
@{
  mpfr_init(params->a);
  mpfr_init(params->b);
  mpfr_init(params->c);

  mpfr_set_d(params->a, 3.0, GMP_RNDN);
  mpfr_set_d(params->b, 2.0, GMP_RNDN);
  mpfr_set_d(params->c, 1.0, GMP_RNDN);
@}
static void
parameters_final (parameters_t * params)
@{
  mpfr_clear(params->a);
  mpfr_clear(params->b);
  mpfr_clear(params->c);
@}

static int
function (mpfr_ptr Y, mpfr_ptr X, void * params_)
@{
  mpfr_t        tmp1;
  mpfr_t        tmp2;
  parameters_t *params = params_;

  mpfr_init(tmp1);
  mpfr_init(tmp2);
  @{
    /* (a * x + b) * x + c */
    mpfr_mul(tmp1, params->a, X, GMP_RNDN);
    mpfr_add(tmp2, tmp1, params->b, GMP_RNDN);
    mpfr_mul(tmp1, tmp2, X, GMP_RNDN);
    mpfr_add(Y, tmp1, params->c, GMP_RNDN);
  @}
  mpfr_clear(tmp1);
  mpfr_clear(tmp2);
  return MP_ODRF_OK;
@}

static int
derivative (mpfr_ptr DY, mpfr_ptr X, void * params_)
@{
  mpfr_t        tmp1;
  mpfr_t        tmp2;
  parameters_t *params = params_;

  mpfr_init(tmp1);
  mpfr_init(tmp2);
  @{
    /* 2 * a * x + b */
    mpfr_mul_d(tmp1, params->a, 2.0, GMP_RNDN);
    mpfr_mul(tmp2, tmp1, X, GMP_RNDN);
    mpfr_add(DY, tmp2, params->b, GMP_RNDN);
  @}
  mpfr_clear(tmp1);
  mpfr_clear(tmp2);
  return MP_ODRF_OK;
@}

static int
function_and_derivative (mpfr_ptr DY, mpfr_ptr Y,
                         mpfr_ptr X, void * params_)
@{
  int                           rv;
  rv = function(Y, X, params_);
  if (MP_ODRF_OK == rv) @{
     rv = derivative(DY, X, params_);
  @}
  return rv;
@}

int
main (int argc MP_ODRF_UNUSED, char * argv [])
@{
  parameters_t                  params;
  mpfr_t                        DY, Y, X;
  mp_odrf_mpfr_function_fdf_t   FDF = @{
    .f          = function,
    .df         = derivative,
    .fdf        = function_and_derivative,
    .params     = &params
  @};
  int                           rv;
  double                        x = 2.4;

  parameters_init(&params);
  mpfr_init(DY);
  mpfr_init(Y);
  mpfr_init(X);
  @{
    mpfr_set_d(X, 2.4, GMP_RNDN);
    rv = MP_ODRF_MPFR_FN_FDF_EVAL_F_DF(&FDF, DY, Y, X);
    mpfr_fprintf(stderr,
                 "%s: y = %20RNf, dy = %20RNf, should be %f and %f\n",
                 argv[0], Y, DY,
                 (3.0 * x * x + 2.0 * x + 1.0),
                 (2.0 * 3.0 * x + 2.0));
    rv = MP_ODRF_MPFR_FN_FDF_EVAL_F(&FDF, Y, X);
    mpfr_fprintf(stderr, "%s: y  = %20RNf\n", argv[0], Y);
    rv = MP_ODRF_MPFR_FN_FDF_EVAL_DF(&FDF, DY, X);
    mpfr_fprintf(stderr, "%s: dy = %20RNf\n", argv[0], DY);
  @}
  mpfr_clear(X);
  mpfr_clear(Y);
  mpfr_clear(DY);
  parameters_final(&params);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c ------------------------------------------------------------

Here is another example for the function:
@tex
$$
f(x) = exp(2 x)
$$
@end tex
@ifinfo

@example
f(x) = exp(2 x)
@end example

@end ifinfo
@noindent
and its derivative:
@tex
$$
f'(x) = 2 exp(2 x) = 2 f(x)
$$
@end tex
@ifinfo

@example
f'(x) = 2 exp(2 x) = 2 f(x)
@end example

@end ifinfo
@noindent
in which we take advantage of the math function and derivative
expressions to save some computation of intermediate results (see the C
function @cfunc{function_and_derivative}).

@smallexample
#include <mp-odrf.h>

typedef struct @{
  mpfr_t        ell;
@} parameters_t;

static void
parameters_init (parameters_t * params)
@{
  mpfr_init(params->ell);
  mpfr_set_d(params->ell, 2.0, GMP_RNDN);
@}
static void
parameters_final (parameters_t * params)
@{
  mpfr_clear(params->ell);
@}

static int
function (mpfr_ptr Y, mpfr_ptr X, void * params_)
@{
  mpfr_t        tmp;
  parameters_t *params = params_;

  mpfr_init(tmp);
  @{
    /* exp(ell * x) */
    mpfr_mul(tmp, params->ell, X, GMP_RNDN);
    mpfr_exp(Y, tmp, GMP_RNDN);
  @}
  mpfr_clear(tmp);
  return MP_ODRF_OK;
@}

static int
derivative (mpfr_ptr DY, mpfr_ptr X, void * params_)
@{
  mpfr_t        tmp1, tmp2;
  parameters_t *params = params_;

  mpfr_init(tmp1);
  mpfr_init(tmp2);
  @{
    /* ell * exp(ell * x) */
    mpfr_mul(tmp1, params->ell, X, GMP_RNDN);
    mpfr_exp(tmp2, tmp1, GMP_RNDN);
    mpfr_mul(DY, params->ell, tmp2, GMP_RNDN);
  @}
  mpfr_clear(tmp1);
  mpfr_clear(tmp2);
  return MP_ODRF_OK;
@}

static int
function_and_derivative (mpfr_ptr DY, mpfr_ptr Y,
                         mpfr_ptr X, void * params_)
@{
  mpfr_t        tmp;
  parameters_t *params = params_;

  mpfr_init(tmp);
  @{
    /*
      y  = exp(ell * x)
      dy = ell * exp(ell * x) = ell * y
    */
    mpfr_mul(tmp, params->ell, X, GMP_RNDN);
    mpfr_exp(Y, tmp, GMP_RNDN);
    mpfr_mul(DY, params->ell, Y, GMP_RNDN);
  @}
  mpfr_clear(tmp);
  return MP_ODRF_OK;
@}

int
main (int argc MP_ODRF_UNUSED, char * argv [])
@{
  parameters_t                  params;
  mpfr_t                        DY, Y, X;
  mp_odrf_mpfr_function_fdf_t   FDF = @{
    .f          = function,
    .df         = derivative,
    .fdf        = function_and_derivative,
    .params     = &params
  @};
  double                        x = 2.4;
  int                           rv;

  parameters_init(&params);
  mpfr_init(DY);
  mpfr_init(Y);
  mpfr_init(X);
  @{
    mpfr_set_d(X, 2.4, GMP_RNDN);
    rv = MP_ODRF_MPFR_FN_FDF_EVAL_F_DF(&FDF, DY, Y, X);
    mpfr_fprintf(stderr,
                 "%s: y = %20RNf, dy = %20RNf, should be %f and %f\n",
                 argv[0], Y, DY,
                 (exp(2.0 * x)),
                 (2.0 * exp(2.0 * x)));
    rv = MP_ODRF_MPFR_FN_FDF_EVAL_F(&FDF, Y, X);
    mpfr_fprintf(stderr, "%s: y  = %20RNf\n", argv[0], Y);
    rv = MP_ODRF_MPFR_FN_FDF_EVAL_DF(&FDF, DY, X);
    mpfr_fprintf(stderr, "%s: dy = %20RNf\n", argv[0], DY);
  @}
  mpfr_clear(X);
  mpfr_clear(Y);
  mpfr_clear(DY);
  parameters_final(&params);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root bounds
@section Search Bounds and Guesses

@cindex root finding, search bounds
@cindex root finding, initial guess

We provide either search bounds or an initial guess; this section
explains how search bounds and guesses work and how function arguments
control them.

A guess is simply an @math{X} value which is iterated until it is within
the desired precision of a root.  It takes the form of an @code{mpfr_t}.

Search bounds are the endpoints of an interval which is iterated until
the length of the interval is smaller than the requested precision.  The
interval is defined by two values, the lower limit and the upper limit.
Whether the endpoints are intended to be included in the interval or not
depends on the context in which the interval is used.

@c page
@node one root iteration
@section Root Finding Iteration


The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any solver of the
corresponding type.  The same functions work for all solvers so that
different methods can be substituted at runtime without modifications to
the code.


@deftypefun int mp_odrf_mpfr_root_fsolver_iterate (mp_odrf_mpfr_root_fsolver_t * @var{S})
@deftypefunx int mp_odrf_mpfr_root_fdfsolver_iterate (mp_odrf_mpfr_root_fdfsolver_t * @var{S})
These functions perform a single iteration of the solver @var{S}.  When
successful return @code{MP_ODRF_OK}, otherwise return a suitable error
code.
@end deftypefun


The solver maintains a current best estimate of the root at all times.
The bracketing solvers also keep track of the current best interval
bounding the root.  This information can be accessed with the following
auxiliary functions.


@deftypefun mpfr_ptr mp_odrf_mpfr_root_fsolver_root (const mp_odrf_mpfr_root_fsolver_t * @var{S})
@deftypefunx mpfr_ptr mp_odrf_mpfr_root_fdfsolver_root (const mp_odrf_mpfr_root_fdfsolver_t * @var{S})
These functions return the current estimate of the root for the solver
@var{S}.  The referenced number is part of solver's state, so it must
@strong{not} be modified.
@end deftypefun


@deftypefun mpfr_ptr mp_odrf_mpfr_root_fsolver_x_lower (const mp_odrf_mpfr_root_fsolver_t * @var{S})
@deftypefunx mpfr_ptr mp_odrf_mpfr_root_fsolver_x_upper (const mp_odrf_mpfr_root_fsolver_t * @var{S})
These functions return the current bracketing interval for the solver
@var{S}.  The referenced numbers are part of solver's state, so they must
@strong{not} be modified.
@end deftypefun

@c page
@node one root stop
@section Search Stopping Parameters


@cindex root finding, stopping parameters


A root finding procedure should stop when one of the following conditions is
true:

@itemize @bullet
@item
A root has been found to within the user--specified precision.

@item
A user--specified maximum number of iterations has been reached.

@item
An error has occurred.
@end itemize

@noindent
The handling of these conditions is under user control.  The functions
below allow the user to test the precision of the current result in
several standard ways.


@deftypefun mp_odrf_code_t mp_odrf_mpfr_root_test_interval (mpfr_t @var{x_lower}, mpfr_t @var{x_upper}, mpfr_t @var{epsabs}, mpfr_t @var{epsrel})
This function tests for the convergence of the interval [@var{x_lower},
@var{x_upper}] with absolute error @var{epsabs} and relative error
@var{epsrel}.  The test returns @code{MP_ODRF_OK} if the following
condition is achieved:
@tex
$$
|a - b| < \hbox{\it epsabs} + \hbox{\it epsrel\/}\, \min(|a|,|b|)
$$
@end tex
@ifinfo

@example
|a - b| < epsabs + epsrel min(|a|,|b|)
@end example

@end ifinfo
@noindent
when the interval @math{x = [a,b]} does not include the origin.  If the
interval includes the origin then @math{\min(|a|,|b|)} is replaced by
zero (which is the minimum value of @math{|x|} over the interval).  This
ensures that the relative error is accurately estimated for roots close
to the origin.

This condition on the interval also implies that any estimate of the
root @math{r} in the interval satisfies the same condition with respect
to the true root @math{r^*}:
@tex
$$
|r - r^*| < \hbox{\it epsabs} + \hbox{\it epsrel\/}\, r^*
$$
@end tex
@ifinfo

@example
|r - r^*| < epsabs + epsrel r^*
@end example

@end ifinfo
@noindent
assuming that the true root @math{r^*} is contained within the interval.

If the condition is not verified: the return value is
@code{MP_ODRF_CONTINUE}.
@end deftypefun


@deftypefun mp_odrf_code_t mp_odrf_mpfr_root_test_delta (mpfr_t @var{x1}, mpfr_t @var{x0}, mpfr_t @var{epsabs}, mpfr_t @var{epsrel})
Test for the convergence of the sequence @dots{}, @var{x0}, @var{x1}
with absolute error @var{epsabs} and relative error @var{epsrel}.  The
test returns @code{MP_ODRF_OK} if the following condition is achieved:
@tex
$$
|x_1 - x_0| < \hbox{\it epsabs} + \hbox{\it epsrel\/}\, |x_1|
$$
@end tex
@ifinfo

@example
|x_1 - x_0| < epsabs + epsrel |x_1|
@end example

@end ifinfo
@noindent
and returns @code{MP_ODRF_CONTINUE} otherwise.
@end deftypefun


@deftypefun mp_odrf_code_t mp_odrf_mpfr_root_test_residual (mpfr_t @var{f}, mpfr_t @var{epsabs})
Test the residual value @var{f} against the absolute error bound
@var{epsabs}.  The test returns @code{MP_ODRF_OK} if the following
condition is achieved:
@tex
$$
|f| < \hbox{\it epsabs}
$$
@end tex
@ifinfo

@example
|f| < epsabs
@end example

@end ifinfo
@noindent
and returns @code{MP_ODRF_CONTINUE} otherwise.  This criterion is
suitable for situations where the precise location of the root,
@math{x}, is unimportant provided a value can be found where the
residual, @math{|f(x)|}, is small enough.
@end deftypefun

@c page
@node one root bracketing
@section Root Bracketing Algorithms


The root bracketing algorithms described in this section require an
initial interval which is guaranteed to contain a root---if @math{a} and
@math{b} are the endpoints of the interval then @math{f(a)} must differ
in sign from @math{f(b)}.  This ensures that the function crosses zero
at least once in the interval.  If a valid initial interval is used then
these algorithms cannot fail, provided the function is well--behaved.

Note that a bracketing algorithm cannot find roots of even degree, since
these do not cross the @math{x}-axis.


@defvr {Solver} mp_odrf_mpfr_root_fsolver_bisection

@cindex bisection algorithm for finding roots
@cindex root finding, bisection algorithm

The @dfn{bisection algorithm} is the simplest method of bracketing the
roots of a function.   It is the slowest algorithm provided by
the library, with linear convergence.

On each iteration, the interval is bisected and the value of the
function at the midpoint is calculated.  The sign of this value is used
to determine which half of the interval does not contain a root.  That
half is discarded to give a new, smaller interval containing the root.
This procedure can be continued indefinitely until the interval is
sufficiently small.

At any time the current estimate of the root is taken as the midpoint of
the interval.

@comment eps file "roots-bisection.eps"
@comment @tex
@comment @sp 1
@comment @center @image{roots-bisection,3.4in}

@comment @quotation
@comment Four iterations of bisection, where @math{a_n} is @math{n}th position of
@comment the beginning of the interval and @math{b_n} is the @math{n}th position
@comment of the end.  The midpoint of each interval is also indicated.
@comment @end quotation
@comment @end tex
@end defvr


@defvr {Solver} mp_odrf_mpfr_root_fsolver_falsepos
@cindex false position algorithm for finding roots
@cindex root finding, false position algorithm

The @dfn{false position algorithm} is a method of finding roots based on
linear interpolation.  Its convergence is linear, but it is usually
faster than bisection.

On each iteration a line is drawn between the endpoints @math{(a,f(a))}
and @math{(b,f(b))} and the point where this line crosses the
@math{x}-axis taken as a ``midpoint''.  The value of the function at
this point is calculated and its sign is used to determine which side of
the interval does not contain a root.  That side is discarded to give a
new, smaller interval containing the root.  This procedure can be
continued indefinitely until the interval is sufficiently small.

The best estimate of the root is taken from the linear interpolation of
the interval on the current iteration.

@comment eps file "roots-false-position.eps"
@comment @tex
@comment @image{roots-false-position,4in}
@comment @quotation
@comment Several iterations of false position, where @math{a_n} is @math{n}th
@comment position of the beginning of the interval and @math{b_n} is the
@comment @math{n}th position of the end.
@comment @end quotation
@comment @end tex
@end defvr


@defvr {Solver} mp_odrf_mpfr_root_fsolver_brent
@cindex Brent's method for finding roots
@cindex root finding, Brent's method

The @dfn{Brent-Dekker method} (referred to here as @dfn{Brent's method})
combines an interpolation strategy with the bisection algorithm.  This
produces a fast algorithm which is still robust.

On each iteration Brent's method approximates the function using an
interpolating curve.  On the first iteration this is a linear
interpolation of the two endpoints.  For subsequent iterations the
algorithm uses an inverse quadratic fit to the last three points, for
higher accuracy.  The intercept of the interpolating curve with the
@math{x}-axis is taken as a guess for the root.  If it lies within the
bounds of the current interval then the interpolating point is accepted,
and used to generate a smaller interval.  If the interpolating point is
not accepted then the algorithm falls back to an ordinary bisection
step.

The best estimate of the root is taken from the most recent
interpolation or bisection.
@end defvr


@c page
@node one root polishing
@section Root Finding Algorithms using Derivatives


The root polishing algorithms described in this section require an
initial guess for the location of the root.  There is no absolute
guarantee of convergence; the function must be suitable for this
technique and the initial guess must be sufficiently close to the root
for it to work.  When these conditions are satisfied then convergence is
quadratic.

These algorithms make use of both the function and its derivative.


@deffn {Derivative Solver} mp_odrf_mpfr_root_fdfsolver_newton
@cindex Newton's method for finding roots
@cindex root finding, Newton's method

Newton's Method is the standard root--polishing algorithm.  The
algorithm begins with an initial guess for the location of the root.  On
each iteration, a line tangent to the function @math{f} is drawn at that
position.  The point where this line crosses the @math{x}-axis becomes
the new guess.  The iteration is defined by the following sequence:
@tex
$$
x_{i+1} = x_i - {f(x_i) \over f'(x_i)}
$$
@end tex
@ifinfo

@example
x_@{i+1@} = x_i - f(x_i)/f'(x_i)
@end example

@end ifinfo
@noindent
Newton's method converges quadratically for single roots, and linearly
for multiple roots.

@comment eps file "roots-newtons-method.eps"
@comment @tex
@comment @sp 1
@comment @center @image{roots-newtons-method,3.4in}

@comment @quotation
@comment Several iterations of Newton's Method, where @math{g_n} is the
@comment @math{n}th guess.
@comment @end quotation
@comment @end tex
@end deffn


@deffn {Derivative Solver} mp_odrf_mpfr_root_fdfsolver_secant
@cindex secant method for finding roots
@cindex root finding, secant method

The @dfn{secant method} is a simplified version of Newton's method which does
not require the computation of the derivative on every step.

On its first iteration the algorithm begins with Newton's method, using
the derivative to compute a first step:
@tex
$$
x_1 = x_0 - {f(x_0) \over f'(x_0)}
$$
@end tex
@ifinfo

@example
x_1 = x_0 - f(x_0)/f'(x_0)
@end example

@end ifinfo
@noindent
Subsequent iterations avoid the evaluation of the derivative by
replacing it with a numerical estimate, the slope of the line through
the previous two points:
@tex
$$
x_{i+1} = x_i - {f(x_i) \over f'_{est}}
 ~\hbox{where}~
 f'_{est} =  {f(x_{i}) - f(x_{i-1}) \over x_i - x_{i-1}}
$$
@end tex
@ifinfo

@example
x_@{i+1@} = x_i f(x_i) / f'_@{est@} where
 f'_@{est@} = (f(x_i) - f(x_@{i-1@})/(x_i - x_@{i-1@})
@end example

@end ifinfo
@noindent
When the derivative does not change significantly in the vicinity of the
root the secant method gives a useful saving.  Asymptotically the secant
method is faster than Newton's method whenever the cost of evaluating
the derivative is more than @math{0.44} times the cost of evaluating the
function itself.  As with all methods of computing a numerical
derivative the estimate can suffer from cancellation errors if the
separation of the points becomes too small.

On single roots, the method has a convergence of order @math{(1 + \sqrt
5)/2} (approximately @math{1.62}).  It converges linearly for multiple
roots.

@comment eps file "roots-secant-method.eps"
@comment @tex
@comment @tex
@comment \input epsf
@comment \medskip
@comment \centerline{\epsfxsize=5in\epsfbox{roots-secant-method.eps}}
@comment @end tex
@comment @quotation
@comment Several iterations of Secant Method, where @math{g_n} is the @math{n}th
@comment guess.
@comment @end quotation
@comment @end tex
@end deffn


@deffn {Derivative Solver} mp_odrf_mpfr_root_fdfsolver_steffenson
@cindex Steffenson's method for finding roots
@cindex root finding, Steffenson's method

The @dfn{Steffenson Method} provides the fastest convergence of all the
routines.  It combines the basic Newton algorithm with an Aitken
``delta--squared'' acceleration.  If the Newton iterates are @math{x_i}
then the acceleration procedure generates a new sequence @math{R_i}:
@tex
$$
R_i = x_i - {(x_{i+1} - x_i)^2 \over (x_{i+2} - 2 x_{i+1} + x_i)}
$$
@end tex
@ifinfo

@example
R_i = x_i - (x_@{i+1@} - x_i)^2 / (x_@{i+2@} - 2 x_@{i+1@} + x_@{i@})
@end example

@end ifinfo
@noindent
which converges faster than the original sequence under reasonable
conditions.  The new sequence requires three terms before it can produce
its first value so the method returns accelerated values on the second
and subsequent iterations.  On the first iteration it returns the
ordinary Newton estimate.  The Newton iterate is also returned if the
denominator of the acceleration term ever becomes zero.

As with all acceleration procedures this method can become unstable if
the function is not well--behaved.
@end deffn

@c page
@node one root examples
@section Examples


@menu
Root bracketing algorithms

* one root examples bisection:: Bisection algorithm with interval
                                stop criterion.
* one root examples falsepos::  Falsepos algorithm with delta
                                stop criterion.
* one root examples brent::     Brent algorithm with residual
                                stop criterion.

Root polishing algorithms

* one root examples newton::    Newton algorithm with delta
                                stop criterion.
* one root examples secant::    Secant algorithm with delta
                                stop criterion.
* one root examples steffenson:: Steffenson algorithm with residual
                                stop criterion.
@end menu

@c page
@node one root examples bisection
@subsection Bisection algorithm with interval stop criterion


@smallexample
#include <stdio.h>
#include <stdlib.h>
#include <mp-odrf.h>

static int
sine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}

int
main (void)
@{
  mp_odrf_mpfr_root_fsolver_t * solver;
  mp_odrf_mpfr_function_t       F = @{
    .function = sine_function,
    .params   = NULL
  @};
  mpfr_t        x_lower, x_upper;
  mpfr_t        epsabs, epsrel;
  int           rv, iteration_count = 0;

  printf("*** One-dimensional root finding:\n\
\tbisection algorithm,\n\
\tinterval stop criterion.\n");

  solver = mp_odrf_mpfr_root_fsolver_alloc(mp_odrf_mpfr_root_fsolver_bisection);
  if (NULL == solver) @{
    fprintf(stderr, "error: %s\n",
            mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
    exit(EXIT_FAILURE);
  @}

  mpfr_init(x_lower);
  mpfr_init(x_upper);
  mpfr_init(epsabs);
  mpfr_init(epsrel);
  @{
    mpfr_set_d(x_lower, -1.0, GMP_RNDN);
    mpfr_set_d(x_upper, +0.5, GMP_RNDN);
    mpfr_set_d(epsabs,  1e-6, GMP_RNDN);
    mpfr_set_d(epsrel,  1e-3, GMP_RNDN);

    rv = mp_odrf_mpfr_root_fsolver_set(solver, &F, x_lower, x_upper);
    if (MP_ODRF_OK !=rv) @{
      fprintf(stderr, "error setting up: %s\n",
              mp_odrf_strerror(rv));
      goto end;
    @}

    mpfr_printf("iteration %2d: [%-26Rf, %-26Rf]\n",
                iteration_count++,
                mp_odrf_mpfr_root_fsolver_x_lower(solver),
                mp_odrf_mpfr_root_fsolver_x_upper(solver));

    do @{
      rv = mp_odrf_mpfr_root_fsolver_iterate(solver);
      if (MP_ODRF_OK != rv) @{
        fprintf(stderr, "error iterating: %s\n",
                mp_odrf_strerror(rv));
        goto end;
      @}

      mpfr_printf("iteration %2d: [%-26Rf, %-26Rf]\n",
                  iteration_count++,
                  mp_odrf_mpfr_root_fsolver_x_lower(solver),
                  mp_odrf_mpfr_root_fsolver_x_upper(solver));

      rv = mp_odrf_mpfr_root_test_interval(mp_odrf_mpfr_root_fsolver_x_lower(solver),
                                           mp_odrf_mpfr_root_fsolver_x_upper(solver),
                                           epsabs, epsrel);
      switch (rv) @{
      case MP_ODRF_OK:
        goto solved;
      case MP_ODRF_CONTINUE:
        break;
      default:
        fprintf(stderr, "error testing: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}
    @} while (MP_ODRF_CONTINUE == rv);
  solved:
    mpfr_printf("result = %Rf\n", mp_odrf_mpfr_root_fsolver_root(solver));
  @}
 end:
  mpfr_clear(epsrel);
  mpfr_clear(epsabs);
  mpfr_clear(x_upper);
  mpfr_clear(x_lower);
  mp_odrf_mpfr_root_fsolver_free(solver);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root examples falsepos
@subsection Falsepos algorithm with delta stop criterion


@smallexample
#include <stdio.h>
#include <stdlib.h>
#include <mp-odrf.h>

static int
sine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}

int
main (void)
@{
  mp_odrf_mpfr_root_fsolver_t * solver;
  mp_odrf_mpfr_function_t       F = @{
    .function = sine_function,
    .params   = NULL
  @};
  mpfr_t        x_lower, x_upper;
  mpfr_t        epsabs, epsrel;
  int           rv, iteration_count = 0;

  printf("*** One-dimensional root finding:\n\
\tfalsepos algorithm,\n\
\tinterval stop criterion.\n");

  solver = mp_odrf_mpfr_root_fsolver_alloc(mp_odrf_mpfr_root_fsolver_falsepos);
  if (NULL == solver) @{
    fprintf(stderr, "error: %s\n",
            mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
    exit(EXIT_FAILURE);
  @}

  mpfr_init(x_lower);
  mpfr_init(x_upper);
  mpfr_init(epsabs);
  mpfr_init(epsrel);
  @{
    mpfr_set_d(x_lower, -1.0, GMP_RNDN);
    mpfr_set_d(x_upper, +0.5, GMP_RNDN);
    mpfr_set_d(epsabs,  1e-6, GMP_RNDN);
    mpfr_set_d(epsrel,  1e-3, GMP_RNDN);

    rv = mp_odrf_mpfr_root_fsolver_set(solver, &F, x_lower, x_upper);
    if (MP_ODRF_OK !=rv) @{
      fprintf(stderr, "error setting up: %s\n",
              mp_odrf_strerror(rv));
      goto end;
    @}

    mpfr_printf("iteration %2d: [%-26Rf, %-26Rf]\n",
                iteration_count++,
                mp_odrf_mpfr_root_fsolver_x_lower(solver),
                mp_odrf_mpfr_root_fsolver_x_upper(solver));

    do @{
      rv = mp_odrf_mpfr_root_fsolver_iterate(solver);
      if (MP_ODRF_OK != rv) @{
        fprintf(stderr, "error iterating: %s\n",
                mp_odrf_strerror(rv));
        goto end;
      @}

      mpfr_printf("iteration %2d: [%-26Rf, %-26Rf]\n",
                  iteration_count++,
                  mp_odrf_mpfr_root_fsolver_x_lower(solver),
                  mp_odrf_mpfr_root_fsolver_x_upper(solver));

      rv = mp_odrf_mpfr_root_test_interval(mp_odrf_mpfr_root_fsolver_x_lower(solver),
                                           mp_odrf_mpfr_root_fsolver_x_upper(solver),
                                           epsabs, epsrel);
      switch (rv) @{
      case MP_ODRF_OK:
        goto solved;
      case MP_ODRF_CONTINUE:
        break;
      default:
        fprintf(stderr, "error testing: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}
    @} while (MP_ODRF_CONTINUE == rv);
  solved:
    mpfr_printf("result = %Rf\n", mp_odrf_mpfr_root_fsolver_root(solver));
  @}
 end:
  mpfr_clear(epsrel);
  mpfr_clear(epsabs);
  mpfr_clear(x_upper);
  mpfr_clear(x_lower);
  mp_odrf_mpfr_root_fsolver_free(solver);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root examples brent
@subsection Brent algorithm with residual stop criterion


@smallexample
#include <stdio.h>
#include <stdlib.h>
#include <mp-odrf.h>

static int
sine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}

int
main (void)
@{
  mp_odrf_mpfr_root_fsolver_t * solver;
  mp_odrf_mpfr_function_t       F = @{
    .function = sine_function,
    .params   = NULL
  @};
  mpfr_t        x_lower, x_upper;
  mpfr_t        epsabs, epsrel;
  int           rv, iteration_count = 0;

  printf("*** One-dimensional root finding:\n\
\tBrent algorithm,\n\
\tinterval stop criterion.\n");

  solver = mp_odrf_mpfr_root_fsolver_alloc(mp_odrf_mpfr_root_fsolver_brent);
  if (NULL == solver) @{
    fprintf(stderr, "error: %s\n",
            mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
    exit(EXIT_FAILURE);
  @}

  mpfr_init(x_lower);
  mpfr_init(x_upper);
  mpfr_init(epsabs);
  mpfr_init(epsrel);
  @{
    mpfr_set_d(x_lower, -1.0, GMP_RNDN);
    mpfr_set_d(x_upper, +0.5, GMP_RNDN);
    mpfr_set_d(epsabs,  1e-6, GMP_RNDN);
    mpfr_set_d(epsrel,  1e-3, GMP_RNDN);

    rv = mp_odrf_mpfr_root_fsolver_set(solver, &F, x_lower, x_upper);
    if (MP_ODRF_OK !=rv) @{
      fprintf(stderr, "error setting up: %s\n",
              mp_odrf_strerror(rv));
      goto end;
    @}

    mpfr_printf("iteration %2d: [%-26Rf, %-26Rf]\n",
                iteration_count++,
                mp_odrf_mpfr_root_fsolver_x_lower(solver),
                mp_odrf_mpfr_root_fsolver_x_upper(solver));

    do @{
      rv = mp_odrf_mpfr_root_fsolver_iterate(solver);
      if (MP_ODRF_OK != rv) @{
        fprintf(stderr, "error iterating: %s\n",
                mp_odrf_strerror(rv));
        goto end;
      @}

      mpfr_printf("iteration %2d: [%-26Rf, %-26Rf]\n",
                  iteration_count++,
                  mp_odrf_mpfr_root_fsolver_x_lower(solver),
                  mp_odrf_mpfr_root_fsolver_x_upper(solver));

      rv = mp_odrf_mpfr_root_test_interval(mp_odrf_mpfr_root_fsolver_x_lower(solver),
                                           mp_odrf_mpfr_root_fsolver_x_upper(solver),
                                           epsabs, epsrel);
      switch (rv) @{
      case MP_ODRF_OK:
        goto solved;
      case MP_ODRF_CONTINUE:
        break;
      default:
        fprintf(stderr, "error testing: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}
    @} while (MP_ODRF_CONTINUE == rv);
  solved:
    mpfr_printf("result = %Rf\n", mp_odrf_mpfr_root_fsolver_root(solver));
  @}
 end:
  mpfr_clear(epsrel);
  mpfr_clear(epsabs);
  mpfr_clear(x_upper);
  mpfr_clear(x_lower);
  mp_odrf_mpfr_root_fsolver_free(solver);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root examples newton
@subsection Newton algorithm with delta stop criterion


@smallexample
#include <stdio.h>
#include <stdlib.h>
#include <mp-odrf.h>

static int
sine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}
static int
cosine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_cos(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}
static int
sine_and_cosine_function (mpfr_ptr DY, mpfr_ptr Y,
                          mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y,  X, GMP_RNDN);
  mpfr_cos(DY, X, GMP_RNDN);
  return MP_ODRF_OK;
@}

int
main (void)
@{
  mp_odrf_mpfr_root_fdfsolver_t *       solver;
  mp_odrf_mpfr_function_fdf_t           F = @{
    .f      = sine_function,
    .df     = cosine_function,
    .fdf    = sine_and_cosine_function,
    .params = NULL
  @};
  mpfr_t                epsabs, epsrel, x1;
  int                   rv, iteration_count = 0;

  printf("*** One-dimensional root finding:\n\
\tnewton algorithm,\n\
\tdelta stop criterion.\n");

  solver = mp_odrf_mpfr_root_fdfsolver_alloc(mp_odrf_mpfr_root_fdfsolver_newton);
  if (NULL == solver) @{
    fprintf(stderr, "error: %s\n",
            mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
    exit(EXIT_FAILURE);
  @}

  mpfr_init(epsabs);
  mpfr_init(epsrel);
  mpfr_init(x1);
  @{
    mpfr_set_d(x1,     -1.0, GMP_RNDN);
    mpfr_set_d(epsabs,  1e-6, GMP_RNDN);
    mpfr_set_d(epsrel,  1e-6, GMP_RNDN);

    rv = mp_odrf_mpfr_root_fdfsolver_set(solver, &F, x1);
    if (MP_ODRF_OK != rv) @{
      fprintf(stderr, "error setting up: %s\n", mp_odrf_strerror(rv));
      goto end;
    @}

    mpfr_printf("iteration %2d: x = %-32Rf\n",
                iteration_count++,
                mp_odrf_mpfr_root_fdfsolver_root(solver));

    do @{
      rv = mp_odrf_mpfr_root_fdfsolver_iterate(solver);
      if (MP_ODRF_OK != rv) @{
        fprintf(stderr, "error iterating: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}

      mpfr_printf("iteration %2d: x = %-32Rf\n",
                  iteration_count++,
                  mp_odrf_mpfr_root_fdfsolver_root(solver));

      rv = mp_odrf_mpfr_root_test_delta(x1, mp_odrf_mpfr_root_fdfsolver_root(solver),
                                        epsabs, epsrel);
      switch (rv) @{
      case MP_ODRF_OK:
        goto solved;
      case MP_ODRF_CONTINUE:
        mpfr_set(x1, mp_odrf_mpfr_root_fdfsolver_root(solver), GMP_RNDN);
        break;
      default:
        fprintf(stderr, "error testing: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}
    @} while (MP_ODRF_OK == rv);
  solved:
    mpfr_printf("result = %Rf\n", mp_odrf_mpfr_root_fdfsolver_root(solver));
  @}
 end:
  mpfr_clear(epsabs);
  mpfr_clear(epsrel);
  mpfr_clear(x1);
  mp_odrf_mpfr_root_fdfsolver_free(solver);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root examples secant
@subsection Secant algorithm with delta stop criterion


@smallexample
#include <stdio.h>
#include <stdlib.h>
#include <mp-odrf.h>

static int
sine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}
static int
cosine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_cos(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}
static int
sine_and_cosine_function (mpfr_ptr DY, mpfr_ptr Y,
                          mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y,  X, GMP_RNDN);
  mpfr_cos(DY, X, GMP_RNDN);
  return MP_ODRF_OK;
@}

int
main (void)
@{
  mp_odrf_mpfr_root_fdfsolver_t *       solver;
  mp_odrf_mpfr_function_fdf_t           F = @{
    .f      = sine_function,
    .df     = cosine_function,
    .fdf    = sine_and_cosine_function,
    .params = NULL
  @};
  mpfr_t                epsabs, epsrel, x1;
  int                   rv, iteration_count = 0;

  printf("*** One-dimensional root finding:\n\
\tsecant algorithm,\n\
\tdelta stop criterion.\n");

  solver = mp_odrf_mpfr_root_fdfsolver_alloc(mp_odrf_mpfr_root_fdfsolver_secant);
  if (NULL == solver) @{
    fprintf(stderr, "error: %s\n",
            mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
    exit(EXIT_FAILURE);
  @}

  mpfr_init(epsabs);
  mpfr_init(epsrel);
  mpfr_init(x1);
  @{
    mpfr_set_d(x1,     -1.0, GMP_RNDN);
    mpfr_set_d(epsabs,  1e-6, GMP_RNDN);
    mpfr_set_d(epsrel,  1e-6, GMP_RNDN);

    rv = mp_odrf_mpfr_root_fdfsolver_set(solver, &F, x1);
    if (MP_ODRF_OK != rv) @{
      fprintf(stderr, "error setting up: %s\n", mp_odrf_strerror(rv));
      goto end;
    @}

    mpfr_printf("iteration %2d: x = %-32Rf\n",
                iteration_count++,
                mp_odrf_mpfr_root_fdfsolver_root(solver));

    do @{
      rv = mp_odrf_mpfr_root_fdfsolver_iterate(solver);
      if (MP_ODRF_OK != rv) @{
        fprintf(stderr, "error iterating: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}

      mpfr_printf("iteration %2d: x = %-32Rf\n",
                  iteration_count++,
                  mp_odrf_mpfr_root_fdfsolver_root(solver));

      rv = mp_odrf_mpfr_root_test_delta(x1, mp_odrf_mpfr_root_fdfsolver_root(solver),
                                        epsabs, epsrel);
      switch (rv) @{
      case MP_ODRF_OK:
        goto solved;
      case MP_ODRF_CONTINUE:
        mpfr_set(x1, mp_odrf_mpfr_root_fdfsolver_root(solver), GMP_RNDN);
        break;
      default:
        fprintf(stderr, "error testing: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}
    @} while (MP_ODRF_OK == rv);
  solved:
    mpfr_printf("result = %Rf\n", mp_odrf_mpfr_root_fdfsolver_root(solver));
  @}
 end:
  mpfr_clear(epsabs);
  mpfr_clear(epsrel);
  mpfr_clear(x1);
  mp_odrf_mpfr_root_fdfsolver_free(solver);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root examples steffenson
@subsection Steffenson algorithm with residual stop criterion


@smallexample
#include <stdio.h>
#include <stdlib.h>
#include <mp-odrf.h>

static int
sine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}
static int
cosine_function (mpfr_ptr Y, mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_cos(Y, X, GMP_RNDN);
  return MP_ODRF_OK;
@}
static int
sine_and_cosine_function (mpfr_ptr DY, mpfr_ptr Y,
                          mpfr_ptr X, void * params_ MP_ODRF_UNUSED)
@{
  mpfr_sin(Y,  X, GMP_RNDN);
  mpfr_cos(DY, X, GMP_RNDN);
  return MP_ODRF_OK;
@}

int
main (void)
@{
  mp_odrf_mpfr_root_fdfsolver_t *       solver;
  mp_odrf_mpfr_function_fdf_t           FDF = @{
    .f      = sine_function,
    .df     = cosine_function,
    .fdf    = sine_and_cosine_function,
    .params = NULL
  @};
  mpfr_t                epsabs, residual, x1;
  int                   rv, iteration_count = 0;

  printf("*** One-dimensional root finding:\n\
\tsteffenson algorithm,\n\
\tresidual stop criterion.\n");

  solver = mp_odrf_mpfr_root_fdfsolver_alloc(mp_odrf_mpfr_root_fdfsolver_steffenson);
  if (NULL == solver) @{
    fprintf(stderr, "error: %s\n",
            mp_odrf_strerror(MP_ODRF_ERROR_NO_MEMORY_FOR_STATE_STRUCT));
    exit(EXIT_FAILURE);
  @}

  mpfr_init(epsabs);
  mpfr_init(residual);
  mpfr_init(x1);
  @{
    mpfr_set_d(x1,     -1.0, GMP_RNDN);
    mpfr_set_d(epsabs,  1e-6, GMP_RNDN);

    rv = mp_odrf_mpfr_root_fdfsolver_set(solver, &FDF, x1);
    if (MP_ODRF_OK != rv) @{
      fprintf(stderr, "error setting up: %s\n", mp_odrf_strerror(rv));
      goto end;
    @}

    mpfr_printf("iteration %2d: x = %-32Rf\n",
                iteration_count++,
                mp_odrf_mpfr_root_fdfsolver_root(solver));

    do @{
      rv = mp_odrf_mpfr_root_fdfsolver_iterate(solver);
      if (MP_ODRF_OK != rv) @{
        fprintf(stderr, "error iterating: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}

      mpfr_printf("iteration %2d: x = %-32Rf\n",
                  iteration_count++,
                  mp_odrf_mpfr_root_fdfsolver_root(solver));

      MP_ODRF_MPFR_FN_FDF_EVAL_F(&FDF, residual,
                                 mp_odrf_mpfr_root_fdfsolver_root(solver));

      rv = mp_odrf_mpfr_root_test_residual(residual, epsabs);
      switch (rv) @{
      case MP_ODRF_OK:
        goto solved;
      case MP_ODRF_CONTINUE:
        mpfr_set(x1, mp_odrf_mpfr_root_fdfsolver_root(solver), GMP_RNDN);
        break;
      default:
        fprintf(stderr, "error testing: %s\n", mp_odrf_strerror(rv));
        goto end;
      @}
    @} while (MP_ODRF_OK == rv);
  solved:
    mpfr_printf("result = %Rf\n", mp_odrf_mpfr_root_fdfsolver_root(solver));
  @}
 end:
  mpfr_clear(epsabs);
  mpfr_clear(x1);
  mp_odrf_mpfr_root_fdfsolver_free(solver);
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node one root references
@section References and Further Reading


For information on the Brent-Dekker algorithm see the following two
papers:

@itemize
@item
R. P. Brent, ``An algorithm with guaranteed convergence for finding a
zero of a function'', @cite{Computer Journal}, 14 (1971) 422--425

@item
J. C. P. Bus and T. J. Dekker, ``Two Efficient Algorithms with Guaranteed
Convergence for Finding a Zero of a Function'', @cite{ACM Transactions of
Mathematical Software}, Vol.@: 1 No.@: 4 (1975) 330--345
@end itemize

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node resources
@appendix On--line resources


The latest version of this package can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}/}

The latest version of @gmp{} is available from:

@center @url{http://gmplib.org/}

The latest version of @mpfr{} is available from:

@center @url{http://www.mpfr.org/}

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

